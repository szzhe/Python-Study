
1、位置参数 
须以正确的顺序传入函数。调用时的数量必须和声明时的一样。

def add(x,y):
    ret = []
    print("{}+{}".format(x,y,ret))
    return ret
print(add(3,5))

3 + 5
8

计算x的n次方

def fn(x, n):
    sum = 1
    while n > 0:
        sum = sum * x
        n = n - 1
    return sum
print(fn(5, 3))

125

2、关键字参数

def add(3,x=3):
    pass
TypeError: add() got multiple values for argument 'x'

def add(y=5,3): # 位置参数必须在关键字参数的前面
    pass
SyntaxError: positional argument follows keyword argument

3、默认参数

def inc(base,x=1):
    return base + x
inc(3) # 4
inc(3,2) #5

def inc(x=0,y):
    pass
SyntaxError: non-default argument follows default argument
注：在定义的时候，默认值参数，必须要在默认参数的后面

def add_end(L=[]):
    L.append('END')
    return L

>>> add_end()
['END']
>>> add_end()
['END', 'END']

说明：Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。

def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L

4、可变参数

def sum(*args): # 可以接受 任意多个参数，参数将组成一个元组
    ret = 0
    for i in args:
        ret += i
    return ret
sum(1,2,3)

sum([1,2,3])
TypeError: unsupported operand type(s) for +=: 'int' and 'list'

def connect(**kwargs): # 能够接受任意多个参数，这些参数组成一个字典，且只能通过关键字参数传递
    print(kwargs,type(kwargs))
    for k, v in kwargs.items():
        print("{} -> {}".format(k, v))
connect(host='127.0.0.1', port=3360)

{'host': '127.0.0.1', 'port': 3360} <class 'dict'>
host -> 127.0.0.1
port -> 3360

connect('127.0.0.1')
TypeError: connect() takes 0 positional arguments but 1 was given

可变参数有两种：
    位置可变参数
    关键字可变参数
可变参数的区别：
    位置可变参数
        参数前面加一个星号，参数构成一个元组，传参只能以位置参数传递
    关键字可变参数
        参数前面加两个星号，参数构成一个字典，传参只能以关键字参数传递
--------------------------------------- YES
可变参数混合使用场景

def fn(*args, **kwargs):
    print(args, kwargs)
fn(1, 2, c=3, d=4)
(1, 2) {'c': 3, 'd': 4}

fn(1,2) # (1, 2) {}
fn(1, b=2) # (1,) {'b': 2}
fn(a=1, b=2) # () {'a': 1, 'b': 2}

fn(c=5, 2, a=1) # 当位置可变参数和关键字可变参数一起使用时，可变位置参数必须在前面
SyntaxError: positional argument follows keyword argument
fn(2, c=5, a=1)
(2,) {'c': 5, 'a': 1}
--------------------------------------- YES
def fn(x, y, *args, **kwargs):
    print(x,end=",")
    print(y,end=",")
    print(args,end=",")
    print(kwargs)
fn(2, 3)
2,3,(),{}

fn(1, 2, 3, 4, x=1)
TypeError: fn() got multiple values for argument 'x'
--------------------------------------- YES
def fn(*args, x):
    print(args)
    print(x)
    
fn(2, 3, 4)
TypeError: fn() missing 1 required keyword-only argument: 'x'
#def定义函数的时候，位置可变参数可以在普通参数之前，但是在位置可变参数之后的普通参数变成了keyword-only参数。keyword-only参数必须要用关键字方式传递，不能通过普通的位置参数传递
fn(2, 3, x=4) 
(2, 3)
4
--------------------------------------- YES
def fn(**kwargs, x): # 关键字可变参数不允许在普通参数之前
    print(kwargs)
    print(x)
SyntaxError: invalid syntax 
缘由：传递的关键字参数可同时被kwargs和x接收，所以提示操作异常
--------------------------------------- YES
def fn(x=5, *args):
    print(x,end=",")
    print(args)
fn(1, 2, 3, 4)
5,(2, 3, 4)

fn()
5,()

def fn(*args, x=5):
    print(x)
    print(args)
fn(1, 2, 3, 4)
5
(1, 2, 3, 4)
--------------------------------------- YES
def fn(x=5, **kwargs):
    print(x, end=",")
    print(kwargs)
fn(a=1, b=2)
5,{'a': 1, 'b': 2}

fn(3, a=1, b=2)
3,{'a': 1, 'b': 2}

def fn(**kwargs,x=5): # # 关键字可变参数不允许在普通参数之前
    print(x, end=",")
    print(kwargs)

SyntaxError: invalid syntax

    默认参数靠后
    可变参数靠后(位置、关键字)
    默认参数和可变参数不可同时出现
---------------------------------------------------------------------------------------------------------------------
### 参数解构

def add(x,y):
    ret = x + y
    print("{}+{}".format(x,y,ret))
    return ret
add(x = 1, y = 2)
1+2
3

lst = [1, 2]
add(lst[0], lst[1])
>>>
add(*lst) # 加一个星号，把一个可迭代对象 解构成位置参数
1+2
3

同理：add(*range(1,3))

** 参数解构 是发生在函数调用的时候，可变参数是发生在函数定义的时候 **

d = {'x': 1, 'y': 2}
add(**d) # 加两个星号，把字典解构出来
1+2
3

add(**{'a': 1, 'b': 2}) # 不存在关键字参数a
TypeError: add() got an unexpected keyword argument 'a'
add(**{'x': 1, 'y': 2, 'a'=3}) # 要完全匹配函数的参数个数
SyntaxError: invalid syntax

--------------------------------------- YES

def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
    
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
或
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

参数解构有两种形式：
    一个星号，解构的对象是一个可迭代对象，解构的结果是位置参数
    两个星号，解构的对象是一个字典，解构的结果是关键字参数
    
--------------------------------------- YES
    
def sum(*args):
    ret = 0
    for x in args:
        ret += x
    return ret
print(sum(*range(10)))
45
--------------------------------------- YES

def fn(**kwargs):
    print(kwargs)
fn(**{'1':1})

{'1': 1}

fn(**{1:1})
TypeError: fn() keywords must be strings # 
---------------------------------------------------------------------------------------------------------------------
*** keyword-only

def fn(*, x): 
    print(x)
    
fn(x=3)
3

fn(1)
TypeError: fn() takes 0 positional arguments but 1 was given
fn(1,x=3)
TypeError: fn() takes 0 positional arguments but 1 positional argument (and 1 keyword-only argument) were given

def fn(x, *, y):
    print(x,end=",")
    print(y)
fn(1, y=2)

1,2

def fn(x, *, y=5):
    print(x,end=",")
    print(y)
fn(1)

1,5

def fn(*, x=1, y=5):
    print(x)
    print(y)
fn(1, y=2)
TypeError: fn() takes 0 positional arguments but 1 positional argument (and 1 keyword-only argument) were given
fn(x=11, y=2)
11
2

金玉良言：默认参数要在关键字参数的后面，默认参数要在可变参数的前面，普通参数在最前面，然后是默认参数，然后是可变参数，位置可变在关键字可变的前面

def fn(*args):
    print(args)
fn(*{1, 2, 3})

(1,2,3) # set是无序的，必须要保证结果和的set的顺序是无关的

*** 小结小结小结 ***

* 位置参数必须在关键字参数的前面

* 默认值参数，必须要在普通默认参数(位置参数、关键字参数)的后面
* 默认值参数，必须指向不变对象！用None这个不变对象来实现，函数体内用if判断None

* 位置可变参数：参数前面加一个星号，参数构成一个元组，传参只能以位置参数传递
* 关键字可变参数：参数前面加两个星号，参数构成一个字典，传参只能以关键字参数传递，传递进去后type类型为dict
* 当位置可变参数和关键字可变参数一起使用时，位置可变参数必须在前面
* 位置可变参数可以在普通参数之前，但是在位置可变参数之后的普通参数变成了keyword-only参数。
  keyword-only参数必须要用关键字方式传递，不能通过普通的位置参数传递
* 关键字可变参数不允许在普通参数之前

* 参数解构有两种形式：
    一个星号，解构的对象是一个可迭代对象，解构的结果是位置参数
    两个星号，解构的对象是一个字典，解构的结果是关键字参数[key必须是str]

* keyword-only

***　补充说明　***

1.在python中，类型属于对象，变量是没有类型的：
a=[1,2,3]
a="Runoob"
以上代码中，[1,2,3]是List类型，"Runoob"是String类型，而变量a是没有类型，她仅仅是一个对象的引用(一个指针)，可以是List类型对象，也可以指向String类型对象。

2.python函数的参数传递：
不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun(a)，传递的只是a的值，没有影响a对象本身。比如在 fun(a)内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。
可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后fun外部的la也会受影响

